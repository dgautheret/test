---
title: "TCGA gene expression data analysis in R"
author: 
  "Guillaume Meurice - Bioinformatics Core, Gustave Roussy"
date: "17/08/2018"
output:
  pdf_document: default
---

# Introduction

This practical course is an initiation to analysis of the gene expression data in the TCGA database using the R language. It requires a minimal knowledge of the R language and can be run entirely within RStudio. An Internet connection is necessary for downloading R packages and TCGA data. 

# Exercice 1 : Retrieve TCGA gene expression data

Data generated by the TCGA project (https://cancergenome.nih.gov) are usually accessed through the GDC portal (https://portal.gdc.cancer.gov) which provides access to clinical and molecular data (Whole Exome, RNA-seq, microarray). Access to raw data (e.g. fastq or BAM files) requires authorization of a *data user commitee*, but processed data are freely accessible. Therefore gene expression data for all TCGA tumors are accessible. Retrieval through the GDC web site is pretty tedious. You'll see it much easier using dedicated R packages. Here we will use the TCGA2STAT package (http://www.liuzlab.org/TCGA2STAT/).  

## 1.1 - Installing the 'TCGA2STAT' R package

### a - Just copy this into your R console 

```{r installation TCGA2STAT, eval=FALSE, echo=TRUE}

### this installs the package on your computer
install.packages("TCGA2STAT")

### This loads the package into R so that you can use it
library(TCGA2STAT)

### This shows the package's documentation 
vignette('TCGA2STAT')
```

### b - Based on the documentation, what is the function for importing TCGA data ?

### c - Print the documentation of this function

```{r display getTCGA help, eval = FALSE, echo = TRUE}
?getTCGA
```


## 1.2 - Retrieve RNA-seq datasets

The cancer types available in TCGA are listed in the GDC portal (https://portal.gdc.cancer.gov/projects) and in appendix A of the TCGA2STAT vignette. Cancer types are described as acronyms such as BRCA for 'Breast Invasive Carcinoma' or HNSC for 'Head and Neck Squamous Cell Carcinoma'.

### a - Using the getTCGA function documentation, retrieve RNA-seq data *RNA-Seq second pipeline*, as well as *clinical data* for cancer *uveal melanoma*.

Create variable `uvm` to store this data : 

```{r download data from TCGA, eval = FALSE, echo = TRUE}
uvm  = getTCGA(disease = "UVM", data.type = "RNASeq2", clinical = TRUE)
```

### b - Visualize retrieved data

'getTCGA' outputs a list of matrices, including :

* 'dat' : matrix of expression values
* 'clinical' : matrix of clinical data  

We can display the size and contents of these matrices: 

```{r visualisation of data from TCGA, eval = FALSE, echo = TRUE}
### Display of uvm contents
dim(uvm$dat)
dim(uvm$clinical)
head(uvm$dat)
head(uvm$clinical)

### Note that sample names are columns of 'dat' and rows of 'clinical':
colnames(uvm$dat)
rownames(uvm$clinical)

### And here are the clinical data available :
colnames(uvm$clinical)

### Display the values in column "vitalstatus" and summarize them
uvm$clinical[,"vitalstatus"]
table(uvm$clinical[,"vitalstatus"])

```


Note that samples names are not exactly the same in clinical and expression data. For instance:

* "TCGA-V4-A9EL" in clinical data, becomes:
* "TCGA-V4-A9EL-01A-11R-A405-07" in expression data.

### c - To facilitate analysis, 'getTCGA' can also returns a merged matrix 'merged.dat' that combines molecular data and one clinical variable. To do this, use the 'cvars' option. Use this option to combine expression and 'pathologyTstage' information (tumor stage in the TNM classification). 
Make sure you understand the structure of the resulting 'uvm$merged.dat' matrix.

```{r visualisation of merged data from TCGA, eval = FALSE, echo = TRUE}
uvm  = getTCGA(disease = "UVM", data.type = "RNASeq2", clinical = TRUE, cvars = "pathologyTstage")

head(uvm$merged.dat[,c(1:10)])
```


\newpage
# Exercice 2 : Exploring RNA-seq expression data

> **Here you will** :

> * "decrypt" R code and get familiar with matrix work
> * reuse someone else's R code 
> * get in touch with the popular ggplot2 graphics package

(adapted from Justine Guegan)

This figure below is drawn from the "Iris" R dataset that is available in every R distribution. The Iris dataframe contains observations of petal and sepal sizes for 150 flowers from 3 iris species (versicolor, setosa et virginica). 

```{r display iris figure, echo = FALSE, eval = TRUE, message = FALSE}
data(iris)
library(ggplot2)
ggplot(iris, aes(x=Species, y=Sepal.Width)) +
      geom_point(
        aes(
          fill   = Species), 
          size   = 5, 
          shape  = 21, 
          colour = "grey20",
          position = position_jitter(width=0.2, height=0.1
        )
      ) +
      geom_boxplot(outlier.colour=NA, aes(fill=Species), colour="grey20", alpha=0.3) +
      ggtitle("Sepal width")
```

Now we'd like to adapt this code and replace "sepal width" by expression levels for a given gene, and species by the tumor stage. We provide the R code for this figure in "iris.R". 

### a - Open iris.R in Rstudio and try to understand what it does. A nice way to do it is to execute the commands one by one. ggplot creates a graph (here named "p2") incrementally. You can check the various stages of the graph by typing p2 in the console after each step. 

### b - You may also run the whole script at once from the R console. Set to the directory where you saved script iris.R (Session –> Set working directory –> Choose directory), then run the source command:

``` {r sourcing irir.R, echo = TRUE, eval = FALSE}
source("iris.R")
```

### c - You find the figure is interesting and you'd like to do the same for displaying  expression of gene A2M as in this figure: 

``` {r display gene figure, echo = FALSE, eval = FALSE}
library(ggplot2)

p2 =  ggplot(uvm$merged.dat, aes(x=PATHOLOGYTSTAGE, y=A2M)) +
      geom_point(
        aes(
          fill   = PATHOLOGYTSTAGE), 
          size   = 5, 
          shape  = 21, 
          colour = "grey20",
          position = position_jitter(width=0.2, height=0.1
        )
      ) +
      ylab("Raw Count")+
      geom_boxplot(outlier.colour=NA, aes(fill=PATHOLOGYTSTAGE), 
                   colour="grey20", alpha=0.3) +
      ggtitle('A2M')
p2

```

#### c.1 - Adapt the code in iris.R to reproduce the above figure

#### c.2 - What are the most populated TNM categories? (tip: use function "table") 

```{r tableTNM, echo = TRUE, eval = FALSE}
table(uvm$merged.dat$PATHOLOGYTSTAGE)
```

#### c.3 - Use a predefined function for displaying graphic expression results 

File "displaygene.r" contains a R function for displaying the expression distribution of a gene across pathology stages. The function also display asterisks in case of signficantly different expression between stages t3a and t4a (T-test). 
Check in the R file how the function should be called. Execute the R file and use the function to display expression profile of a gene of your choice.

```{r fonction display expression et stats, echo = TRUE, eval = FALSE}
source ("displaygene.r")
displayExp(uvm$merged.dat,"SHC1")
```

\newpage

# Exercise 3 : Functional analysis

> **Objectives of exercise** :

> * Import text files into R
> * Display heatmaps with the pheatmap package
> * handle dataframes and matrices

A recent paper on uveal melanoma (https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5407684/) has identified two classes of genes based on transcriptome data, one of which is associated to a bad prognostic (class 2). This work was done with Affymetrix gene microarrays. Let's see if we find the same results using TCGA RNA-seq data.

## 3.1 - Import gene list from the publication

This list is available in file uvm.gene.list.txt. Genes are annotated by their "Class". Class 1 genes are overexpressed in low risk patients, Class 2 genes are overexpressed in high-risk patients. 

```{r import gene list, echo = TRUE, eval = FALSE}
genes = read.delim("uvm.gene.list.txt", sep = "\t")
```

## 3.2 - Try to understand what the next command is doing (you may run the command in part)

```{r find index to remove, echo = TRUE, eval = FALSE}
idxToRemove = which(genes$GeneSymbol %in% rownames(uvm$dat) == FALSE)
```

## 3.3 - Now remove genes from list to get a "clean"" list of signature genes that are present in our expression data. Extract expression for all genes in the clean list, from the expression matrix.

```{r clean list, echo = TRUE, eval = FALSE}
genes.clean = genes[-idxToRemove,]
uvm.sub = uvm$dat[as.vector(genes.clean$GeneSymbol),]
```

## 3.4 - Create heatmap

### a - Install and load package 'pheatmap'

```{r pheatmap installation, echo = TRUE, eval = FALSE}
install.packages("pheatmap")
library(pheatmap)
```

### b - Read the 'pheatmap' function documentation

### c - First we prepare data

A log transformation is often much better for heatmap rendering.

```{r heatmap, echo = TRUE, eval = FALSE}
## Expression data
uvm.sub.log = log2(uvm.sub)
pheatmap(
  mat = uvm.sub.log,
  scale = "row", 
  show_colnames = FALSE
)
```

### d - Add annotations to rows and columns

```{r annotation, echo = TRUE, eval = FALSE}
## annotation of rows with gene Class
row_annot = data.frame(Class = genes.clean$Class)
rownames(row_annot) = rownames(uvm.sub)

## annotation of columns with fields 3, 7, 8, 11 of clinical data
cn = gsub(pattern = "-\\d{2}[AB].*$", replacement = "", colnames(uvm.sub.log))
colnames(uvm.sub.log) = cn
col_annot = as.data.frame(uvm$clinical)
col_annot = col_annot[,c(3,7,8,11)]

## Display heatmap
pheatmap(
  mat = uvm.sub.log,
  annotation_row = row_annot,
  annotation_col = col_annot,
  scale = "row", 
  show_colnames = FALSE
)
```

\newpage
# Exercise 4 : Differential expression analysis with DESeq2

> **Objectives of exercise** :

> * Learn basic usage of DESeq2
> * manipulate dataframes and matrices

Differential analysis is for determining gene expression differences between 2 or more sample groups. There are many methods for this, but the most popular for count data (such as what we get from RNA-seq) is DESeq2. Let's run a DESeq2 analysis...

## 4.1 - DESeq2 Installation 

DESeq2 is not available on the generic R repository (CRAN), but it can be found in the biology-specific package repository called 'Bioconductor'. Each package has its own web page, hence:
https://bioconductor.org/packages/release/bioc/html/DESeq2.html. 'DESeq2' installation instructions are found on this page. 

```{r install DESeq2, echo = TRUE, eval = FALSE}
source("https://bioconductor.org/biocLite.R")
biocLite("DESeq2")

## load package
library(DESeq2)

## get documentation :
vignette("DESeq2")
```


## 4.2 - Constructing a "DESeqDataSet" and running DESeq

Open and examine the "DESeq.R" script. The script creates a DESeq data set and runs DEseq. A "DESeqDataSet" is an R object (a special data structure). The vignette says there are 4 methods to create this object. The best one for us is method 2, the one starting with a count matrix (for us `uvm$dat`). The script creates a count matrix 'cts', a sample information matrix 'coldata' and a variable 'dds' that will hold the DESeqDataSet object. The script then runs DESeq on this object. 

N.B : Note that several code lines are devoted to formatting of sample names, as requested by the DESeqDataSet vignette : **It is absolutely critical that the columns of the count matrix and the rows of the column data (information about samples) are in the same order. DESeq2 will not make guesses as to which column of the count matrix belongs to which row of the column data, these must be provided to DESeq2 already in consistent order.**

Run the script line by line and make sure you understand every step. What conditions are compared in the final variables res.vitalstatus and res.t3a_t4a? What is the content of these variables? 

```{r deseq, echo = TRUE, eval = FALSE}

# This command runs the full file at once
source ("DESeq.R")

```

## 4.3 - Playing with DESeq2 results 

Let's play with the contents of DESeq results stored in the dataframe res.vitalstatus. 

### a. First, remove all lines with padj=NA from dataframe. Then extract all significant differential genes with abs(log fold change) >2 and adjusted P-value < 1e-3.

```{r play with deseq, echo = TRUE, eval = FALSE}

# remove NA from DESeq results 
myres=res.vitalstatus[!is.na(res.vitalstatus$padj),]

# Extract genes above a certain fold change and P-value cutoff and save in file
selection=myres[abs(myres$log2FoldChange)>2 & myres$padj<0.001,]
nrow(selection)
write.table(selection, file="myselection.txt", quote=F)

```

### b. Create a copy of the DESeq.R script and modify it for analysing differential expression between male and female patients. Extract a "top set" of significant genes. 

```{r play with deseq 2, echo = TRUE, eval = FALSE}
# to run a gender comparison, modify the DESeq2 script with:
dds <- DESeqDataSetFromMatrix(countData = cts,
                              colData = coldata,
                              design = ~ gender)
dds = DESeq(dds)
res.gender <- results(dds, contrast=c("gender", "male", "female"))

# then, to extract a top set:
myres=res.gender[!is.na(res.gender$padj),]
selection=myres[abs(myres$log2FoldChange)>2 & myres$padj<0.001,]
write.table(selection, file="myselection.txt", quote=F)
```

## 4.3 - Displaying a VolcanoPlot

Let's use the function in file "volcanoPlot.R" to create a volcano plot. Open the file and check the function parameters. Execute the file and use the volcanoPlot function to display results of differential expression between patients with Vital Status = 0 and 1, using the above DESeq results. Set the volcanoPlot parameters to highlight genes with FC>2 and P value <1e3.

```{r volcanoplot function, echo = TRUE, eval = FALSE}

# executes the file
source ("volcanoPlot.R")

# Now use the function
volcanoPlot(res.vitalstatus,fc=2,p.val=0.001,adjusted.pval = T)
```

